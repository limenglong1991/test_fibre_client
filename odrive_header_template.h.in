/*
* This file was autogenerated using the "odrivetool generate-code" feature.
*
* The file matches a specific firmware version. If you add/remove/rename any
* properties exposed by the ODrive, this file needs to be regenerated, otherwise
* the ODrive will ignore all commands.
*/

#ifndef __ODRIVE_ENDPOINTS_HPP
#define __ODRIVE_ENDPOINTS_HPP
#include <stdint.h>
#include <QObject>
{% macro enum_name(endpoint) %}{{ endpoint.name | replace('.', '__') | upper }}{% endmacro %}

typedef struct {
    uint16_t json_crc;
    uint16_t endpoint_id;
} endpoint_ref_t;

class fibre:public QObject {
    Q_OBJECT
public:
    enum fibre_id{ {% for endpoint in endpoints %}
        {{enum_name(endpoint)}} = {{endpoint.id}},
    {%- endfor %}

        // Per-Axis endpoints (to be used with read_axis_property and write_axis_property)
    {%- for endpoint in axis_endpoints %}
        {{enum_name(endpoint)}} = {{endpoint.id}},
    {%- endfor %}
    };
    Q_ENUM(fibre_id)
};

namespace odrive {

static constexpr const uint8_t axis_count = 2;    
    
static constexpr const uint16_t json_crc = 0x{{ "%0x" | format(json_crc) }};

static constexpr const uint16_t per_axis_offset = {{ per_axis_offset }};

template<int I>
struct endpoint_type;

{% for endpoint in endpoints -%}
template<> struct endpoint_type<fibre::{{enum_name(endpoint)}}> { typedef {{endpoint.type}} type; };
{% endfor %}

// Per-axis endpoints
{% for endpoint in axis_endpoints -%}
template<> struct endpoint_type<fibre::{{enum_name(endpoint)}}> { typedef {{endpoint.type}} type; };
{% endfor %}

template<int I>
using endpoint_type_t = typename endpoint_type<I>::type;

}

#endif // __ODRIVE_ENDPOINTS_HPP
